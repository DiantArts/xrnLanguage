///////////////////////////////////////////////////////////////////////////
// Precompilled headers
///////////////////////////////////////////////////////////////////////////
#include <pch.hpp>

///////////////////////////////////////////////////////////////////////////
// Headers
///////////////////////////////////////////////////////////////////////////
#include <xrn/Language/Lexer.hpp>



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Constructors
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
::xrn::language::TokenPool::TokenPool() noexcept = default;

///////////////////////////////////////////////////////////////////////////
::xrn::language::TokenPool::TokenPool(
    TokenPool::Type&& expression
) noexcept
    : m_expression{ ::std::move(expression) }
{}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Iterators support
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
auto ::xrn::language::TokenPool::begin()
    -> TokenPool::Type::iterator
{
    return m_expression.begin();
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::language::TokenPool::begin() const
    -> TokenPool::Type::const_iterator
{
    return m_expression.begin();
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::language::TokenPool::cbegin() const
    -> TokenPool::Type::const_iterator
{
    return m_expression.cbegin();
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::language::TokenPool::end()
    -> TokenPool::Type::iterator
{
    return m_expression.end();
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::language::TokenPool::end() const
    -> TokenPool::Type::const_iterator
{
    return m_expression.end();
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::language::TokenPool::cend() const
    -> TokenPool::Type::const_iterator
{
    return m_expression.cend();
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::language::TokenPool::size() const
    -> ::std::size_t
{
    return m_expression.size();
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::language::TokenPool::operator[](
    ::std::size_t i
) -> ::std::shared_ptr<TokenPool::SubType>&
{
    return m_expression[i];
}
