///////////////////////////////////////////////////////////////////////////
// Precompilled headers
///////////////////////////////////////////////////////////////////////////
#include <pch.hpp>

///////////////////////////////////////////////////////////////////////////
// Headers
///////////////////////////////////////////////////////////////////////////
#include <xrn/Language/Token/AToken.hpp>



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Constructors
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
::xrn::language::AToken::AToken(
    ::xrn::language::token::Type type,
    ::std::size_t lineNumber,
    ::std::size_t characterNumber
) noexcept
    : m_type{ type }
    , m_lineNumber{ lineNumber }
    , m_characterNumber{ characterNumber }
{}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Rule of 5
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
::xrn::language::AToken::~AToken() = default;

///////////////////////////////////////////////////////////////////////////
::xrn::language::AToken::AToken(
    AToken&& that
) noexcept = default;

///////////////////////////////////////////////////////////////////////////
auto ::xrn::language::AToken::operator=(
    AToken&& that
) noexcept
    -> AToken& = default;



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Type comparator
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
auto ::xrn::language::AToken::isNumber() const
    -> bool
{
    switch (m_type) {
    case ::xrn::language::token::Type::INT_LITERAL:
    case ::xrn::language::token::Type::FLOAT_LITERAL:
    case ::xrn::language::token::Type::I8:
    case ::xrn::language::token::Type::I16:
    case ::xrn::language::token::Type::I32:
    case ::xrn::language::token::Type::I64:
    case ::xrn::language::token::Type::F8:
    case ::xrn::language::token::Type::F16:
    case ::xrn::language::token::Type::F32:
    case ::xrn::language::token::Type::F64:
    case ::xrn::language::token::Type::SIZE:
        return true;
    default:
        return false;
    };
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::language::AToken::isType(
    ::xrn::language::token::Type comparativeType
) const
    -> bool
{
    return m_type == comparativeType;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Getters
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
auto ::xrn::language::AToken::getType() const
    -> ::xrn::language::token::Type
{
    return m_type;
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::language::AToken::getAsString() const
    -> ::std::string
{
    ::std::string ret{ "<" };
    ret += ::xrn::language::token::TypeStr[m_type];
    ret += ';';
    ret += this->getValueAsString();

    // ret += ';';
    // ret += ::std::to_string(m_lineNumber + 1);
    // ret += ':';
    // ret += ::std::to_string(m_characterNumber + 1);

    ret += '>';
    return ret;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Others
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
::std::ostream& operator<<(
    ::std::ostream& os,
    const ::xrn::language::AToken& token
)
{
    os << token.getAsString();
    return os;
}
