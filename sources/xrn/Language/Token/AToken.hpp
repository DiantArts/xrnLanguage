#pragma once

namespace xrn::language::token {

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Types
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
/// \brief Type of token
///
///////////////////////////////////////////////////////////////////////////
enum Type {
    INVALID = 0,
    KEYWORD,
    OPERATOR,
    COMPARATOR,
    ACCESSOR,
    SEPARATOR,
    IDENTIFIER,
    BOOLEAN, // b
    STRING, // s, ""
    CHARACTER, // ''
    TYPE_SPECIFIER,
    FUNCTION,
    FUNCTION_DECLARATION,
    FUNCTION_DEFINITION,
    FUNCTION_CALL,
    SPECIAL_MEMBER_FUNCTION, // __*
    SPECIAL_MEMBER_FUNCTION_DECLARATION, // __*
    SPECIAL_MEMBER_FUNCTION_DEFINITION, // __*
    SPECIAL_MEMBER_FUNCTION_CALL, // __*
    LINE_COMMENT, // #
    MULTI_LINE_COMMENT, // #* *#

    INT_LITERAL,
    FLOAT_LITERAL,
    I8, // i8, bi
    I16, // i16, -
    I32, // i32, i
    I64, // I64
    F8, // f8, bf
    F16, // f16, -
    F32, // f32, f
    F64, // f64, d
    SIZE, // sz
};

///////////////////////////////////////////////////////////////////////////
/// \brief Type of token as string
///
///////////////////////////////////////////////////////////////////////////
static inline constexpr const ::std::string_view TypeStr[]{
    "invalid = 0",
    "keyword",
    "operator",
    "comparator",
    "accessor",
    "separator",
    "identifier",
    "boolean",
    "string",
    "character",
    "type_specifier",
    "function",
    "function_declaration",
    "function_definition",
    "function_call",
    "special_member_function",
    "special_member_function_declaration",
    "special_member_function_definition",
    "special_member_function_call",
    "line_comment",
    "multi_line_comment",
    "int_literal",
    "float_literal",
    "i8",
    "i16",
    "i32",
    "i64",
    "f8",
    "f16",
    "f32",
    "f64",
    "size",
};

} // namespace xrn::language::token



namespace xrn::language {

///////////////////////////////////////////////////////////////////////////
/// \brief Allows simple AToken manipulations
/// \ingroup language
///
/// \include AToken.hpp <xrn/Language/AToken.hpp>
///
/// Compiles xrn code into an executable
///
/// Usage example:
/// \code
/// \endcode
///
///////////////////////////////////////////////////////////////////////////
class AToken {

public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Constructors
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    AToken(
        ::xrn::language::token::Type type,
        ::std::size_t lineNumber,
        ::std::size_t characterNumber
    ) noexcept;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Rule of 5
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Destructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    virtual ~AToken() = 0;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    AToken(
        const AToken& other
    ) noexcept = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Copy assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto operator=(
        const AToken& other
    ) noexcept
        -> AToken& = delete;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move constructor
    ///
    ///////////////////////////////////////////////////////////////////////////
    AToken(
        AToken&& that
    ) noexcept;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Move assign operator
    ///
    ///////////////////////////////////////////////////////////////////////////
    auto operator=(
        AToken&& that
    ) noexcept
        -> AToken&;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Virtual
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Get the token as string
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] virtual auto getValueAsString() const
        -> ::std::string = 0;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Type comparator
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto isNumber() const
        -> bool;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto isFloatingPoint() const
        -> bool;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto isInteger() const
        -> bool;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto isFunctionCall() const
        -> bool;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto isType(
        ::xrn::language::token::Type comparativeType
    ) const
        -> bool;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Getters
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getType() const
        -> ::xrn::language::token::Type;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Formats the token information for string
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getAsString() const
        -> ::std::string;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getLineNumber() const
        -> ::std::size_t;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto getCharacterNumber() const
        -> ::std::size_t;



protected:

    ::xrn::language::token::Type m_type;
    ::std::size_t m_lineNumber;
    ::std::size_t m_characterNumber;

};

} // namespace xrn::language

::std::ostream& operator<<(
    ::std::ostream& os,
    const ::xrn::language::AToken& token
);
