///////////////////////////////////////////////////////////////////////////
// Precompilled headers
///////////////////////////////////////////////////////////////////////////
#include <pch.hpp>

///////////////////////////////////////////////////////////////////////////
// Headers
///////////////////////////////////////////////////////////////////////////
#include <xrn/Language/Lexer.hpp>



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Constructors
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
::xrn::language::Expression::Expression() noexcept = default;

///////////////////////////////////////////////////////////////////////////
::xrn::language::Expression::Expression(
    Expression::Type&& expression
) noexcept
    : m_expression{ ::std::move(expression) }
{}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Comparisons
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
/// \brief Is the expression complete
///
/// Check if the expression ends with a ';'
///
///////////////////////////////////////////////////////////////////////////
[[ nodiscard ]] auto ::xrn::language::Expression::isComplete()
    -> bool
{
    if (!m_expression.size()) {
        return false;
    }
    auto& back{ *m_expression.back() };
    return back.getType() == ::xrn::language::token::Type::SEPARATOR && (
            back.getValueAsString() == ";" ||
            back.getValueAsString() == "{" ||
            back.getValueAsString() == "}"
        );
}

///////////////////////////////////////////////////////////////////////////
/// \brief Is the expression syntactically valid
///
///////////////////////////////////////////////////////////////////////////
[[ nodiscard ]] auto ::xrn::language::Expression::isValid()
    -> bool
{
    return false;
}



///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Iterators support
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
auto ::xrn::language::Expression::begin()
    -> Expression::Type::iterator
{
    return m_expression.begin();
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::language::Expression::begin() const
    -> Expression::Type::const_iterator
{
    return m_expression.begin();
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::language::Expression::cbegin() const
    -> Expression::Type::const_iterator
{
    return m_expression.cbegin();
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::language::Expression::end()
    -> Expression::Type::iterator
{
    return m_expression.end();
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::language::Expression::end() const
    -> Expression::Type::const_iterator
{
    return m_expression.end();
}

///////////////////////////////////////////////////////////////////////////
auto ::xrn::language::Expression::cend() const
    -> Expression::Type::const_iterator
{
    return m_expression.cend();
}
