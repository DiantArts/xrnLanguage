#pragma once

#include <xrn/Language/Token.hpp>

namespace xrn::language {

///////////////////////////////////////////////////////////////////////////
/// \brief Allows simple Expression manipulations
/// \ingroup language
///
/// \include Expression.hpp <xrn/Language/Expression.hpp>
///
/// Compiles xrn code into an executable
///
/// Usage example:
/// \code
/// \endcode
///
///////////////////////////////////////////////////////////////////////////
class Expression {

public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // static elements
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Type internally contained by the container of the class
    ///
    ///////////////////////////////////////////////////////////////////////////
    using SubType = ::xrn::language::AToken;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Type internally contained by the class
    ///
    ///////////////////////////////////////////////////////////////////////////
    using Type = ::std::vector<::std::unique_ptr<Expression::SubType>>;



public:

    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Constructors
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Expression() noexcept;

    ///////////////////////////////////////////////////////////////////////////
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Expression(
        Expression::Type&& expression
    ) noexcept;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Comparisons
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Is the expression complete
    ///
    /// Check if the expression ends with a ';'
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto isComplete()
        -> bool;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Is the expression syntactically valid
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto isValid()
        -> bool;



    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Container support
    //
    ///////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Gets an iterator to the begining of the vector of entities
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto begin()
        -> Expression::Type::iterator;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Gets an iterator to the begining of the vector of entities
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto begin() const
        -> Expression::Type::const_iterator;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Gets an iterator to the begining of the vector of entities
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto cbegin() const
        -> Expression::Type::const_iterator;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Gets an iterator to the end of the vector of entities
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto end()
        -> Expression::Type::iterator;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Gets an iterator to the end of the vector of entities
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto end() const
        -> Expression::Type::const_iterator;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Gets an iterator to the end of the vector of entities
    ///
    ///////////////////////////////////////////////////////////////////////////
    [[ nodiscard ]] auto cend() const
        -> Expression::Type::const_iterator;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Add the argument to the container
    ///
    ///////////////////////////////////////////////////////////////////////////
    void add(
        auto&&... arg
    );

    ///////////////////////////////////////////////////////////////////////////
    /// \brief Add the argument to the container
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <
        typename T
    > void add(
        ::std::unique_ptr<T>&& arg
    );




private:

    Expression::Type m_expression;

};

} // namespace xrn::language

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
// Header-implementation
//
///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
#include <xrn/Language/Expression.impl.hpp>
